//---------------------------------------------------------------------
//		二次元高速ウォルシュ-アダマール変換	8*8専用
//---------------------------------------------------------------------
/*
8*8専用の高速アダマール変換
難しい処理はせず、2*2のアダマール変換を積み重ねるアルゴリズム通りに加減算を繰り返す単純な処理です
この方が高速かな、と
*/

#include <cstdint>

//---------------------------------------------------------------------
//		二次元高速ウォルシュ-アダマール変換関数
//---------------------------------------------------------------------
#pragma omp declare simd uniform(source) inbranch
void fwht(int_fast32_t &source) {

  // 配列を使用しないほうが処理が早かったです。
  // Cでは当然なのでしょうか?
  int_fast32_t a0, a1, a2, a3, a4, a5, a6, a7;
  int_fast32_t b0, b1, b2, b3, b4, b5, b6, b7;

  int_fast32_t *p = &source;

#pragma omp simd
  for (int_fast16_t i = 0; i < 8; i++) {
    a0   = p[0] + p[1];
    a1   = p[0] - p[1];
    a2   = p[2] + p[3];
    a3   = p[2] - p[3];
    a4   = p[4] + p[5];
    a5   = p[4] - p[5];
    a6   = p[6] + p[7];
    a7   = p[6] - p[7];

    b0   = a0 + a2;
    b2   = a0 - a2;
    b1   = a1 + a3;
    b3   = a1 - a3;
    b4   = a4 + a6;
    b6   = a4 - a6;
    b5   = a5 + a7;
    b7   = a5 - a7;

    p[0] = b0 + b4;
    p[4] = b0 - b4;
    p[1] = b1 + b5;
    p[5] = b1 - b5;
    p[2] = b2 + b6;
    p[6] = b2 - b6;
    p[3] = b3 + b7;
    p[7] = b3 - b7;

    p += 8;
  }
  p = &source;

#pragma omp simd
  for (int_fast16_t i = 0; i < 8; i++) {
    a0    = p[0] + p[8];
    a1    = p[0] - p[8];
    a2    = p[16] + p[24];
    a3    = p[16] - p[24];
    a4    = p[32] + p[40];
    a5    = p[32] - p[40];
    a6    = p[48] + p[56];
    a7    = p[48] - p[56];

    b0    = a0 + a2;
    b2    = a0 - a2;
    b1    = a1 + a3;
    b3    = a1 - a3;
    b4    = a4 + a6;
    b6    = a4 - a6;
    b5    = a5 + a7;
    b7    = a5 - a7;

    p[0]  = (b0 + b4) >> 3;
    p[32] = (b0 - b4) >> 3;
    p[8]  = (b1 + b5) >> 3;
    p[40] = (b1 - b5) >> 3;
    p[16] = (b2 + b6) >> 3;
    p[48] = (b2 - b6) >> 3;
    p[24] = (b3 + b7) >> 3;
    p[56] = (b3 - b7) >> 3;

    p++;
  }

  /*
  以下、シンプルなアダマール変換です
  基底関数どおりに単純に加減算を繰り返すものです
  計算量が多いのでとうぜん高速アダマール変換よりも遅くなります
  もしかしたらマルチスレッドとかSSE化などに向いているかもしれないので残しておきます
  */

  /*
   int i,x;
   int *p,*p2;

   int temp[64];

   p = source;
   p2= temp;

   for(i=0;i<2;i++){
    for(x=0;x<8;x++) {

     p2[0]  = p[0]+p[1]+p[2]+p[3]+p[4]+p[5]+p[6]+p[7];
     p2[8]  = p[0]+p[1]+p[2]+p[3]-p[4]-p[5]-p[6]-p[7];
     p2[16] = p[0]+p[1]-p[2]-p[3]-p[4]-p[5]+p[6]+p[7];
     p2[24] = p[0]+p[1]-p[2]-p[3]+p[4]+p[5]-p[6]-p[7];
     p2[32] = p[0]-p[1]-p[2]+p[3]+p[4]-p[5]-p[6]+p[7];
     p2[40] = p[0]-p[1]-p[2]+p[3]-p[4]+p[5]+p[6]-p[7];
     p2[48] = p[0]-p[1]+p[2]-p[3]-p[4]+p[5]-p[6]+p[7];
     p2[56] = p[0]-p[1]+p[2]-p[3]+p[4]-p[5]+p[6]-p[7];

     p+=8; p2++;
    }
    p = temp;
    p2= source;
   }

   for(i=0;i<64;i++) source[i]/=8;
  */
}
